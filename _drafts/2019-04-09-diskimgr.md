---
layout: post
title: A simple disk imaging workflow tool
tags: [disk-imaging, diskimgr, web-archaeology]
---

<figure class="image">
  <img src="{{ BASE_PATH }}/images/2019/04/floppies.jpg" alt="Photograph of SATA hard disk, USB Flash drive and 3.5 floppy disks">
  <figcaption>SATA hard disk, USB Flash drive and 3.5" floppy disks</figcaption>
</figure>

As I explained in the introduction of [this earlier blog post]({{ BASE_PATH }}/2019/01/31/roll-the-tape-recovering-90s-data-tapes-in-bitcurator), within our ongoing web archaeology project we are currently developing workflows for reading data from a variety of physical carrier formats. After the earlier work on [data tapes]({{ BASE_PATH }}/2019/01/31/roll-the-tape-recovering-90s-data-tapes-in-bitcurator) and [optical media]({{ BASE_PATH }}/2019/03/22/a-simple-workflow-tool-for-imaging-optical-media-using-readom-and-ddrescue), the next job was to image a small box with 3.5" floppy disks. Easy enough, and my first thought was to fire up [*Guymager*](https://guymager.sourceforge.io/) and be done with it. But this turned out to be less straightforward than expected.

<!-- more -->

## Problems with Guymager-based workflow

Similar to the optical media case, the main problem here is the handling of metadata. *Guymager* does in fact accommodate for this, but the way it is implemented introduces some practical problems. To illustrate this, here's *Guymager*'s default entry form: 

<figure class="image">
  <img src="{{ BASE_PATH }}/images/2019/04/guymager-entry.png" alt="Screenshot of Guymager entry form, Expert Witness format">
  <figcaption>Guymager entry form, Expert Witness format</figcaption>
</figure>

The form provides various fields that can be used to enter descriptive metadata, but they are *only* available if the disk image is written in [*Expert Witness*](https://www.loc.gov/preservation/digital/formats/fdd/fdd000406.shtml) format. Changing the format to *Linux dd raw image* (which simply generates a raw copy of the imaged medium's bytestream) disables these fields:

<figure class="image">
  <img src="{{ BASE_PATH }}/images/2019/04/guymager-dd.png" alt="Screenshot of Guymager entry form, dd format">
  <figcaption>Guymager entry form, dd format</figcaption>
</figure>

One possible solution would be to image the floppies to *Expert Witness* format (*EWF*), in which case the entered descriptor fields are embedded in the disk image. However, I really don't want to do this. First, saving to *EWF* would make further processing of the disk image (e.g. mounting the file system, or attaching it to a virtual machine or emulator) more difficult, since it requires that the reading application (emulator, disk mount tool) supports not only the floppy's native file system (typically [*FAT*](https://forensicswiki.org/wiki/FAT) for floppies that were written with MS-DOS or Windows), but also the added *EWF* layer. Also, while *EWF*'s support for data compression can be  tremendously useful for imaging large hard disks, it is largely unnecessary for 1.5 MB floppies. Last but not least, *Guymager*'s interface 

<!-- add section + add photo of floppy with written label -->


An alternative solution would be to select the *Linux dd raw* option in *Guymager*, and then add the metadata by hand afterwards. As I argued in [my previous blog post]({{ BASE_PATH }}/2019/03/22/a-simple-workflow-tool-for-imaging-optical-media-using-readom-and-ddrescue), this is pretty cumbersome, and also prone to all sorts of errors.

## Diskimgr

As the [*omimgr*](https://github.com/KBNLresearch/omimgr) already solves the above problem for optical media, I simply used that tool's code as a starting point, and adapted it into [*diskimgr*](https://github.com/KBNLresearch/diskimgr). *Diskimgr* is a general-purpose disk imaging tool that can be used for a wide variety of digital media, such a floppy disks, USB Flash drives and hard disks. It provides a simple graphical user interface for the entry of descriptive metadata, and all entered and generated metadata are written to a JSON file, along with the image file.

<figure class="image">
  <img src="{{ BASE_PATH }}/images/2019/04/diskimgr-1.png" alt="Screenshot of diskimgr interface">
  <figcaption>Diskimgr interface</figcaption>
</figure>

Internally *diskimgr* simply wraps around [*Unix dd*](https://linux.die.net/man/1/dd) and [*ddrescue*](https://linux.die.net/man/1/ddrescue). The general workflow of *diskimgr* is very similar to the one employed by *omimgr*: first it tries to read a user-defined medium with *dd*. If *dd* fails, it prompts the user to give it another try with *ddrescue*. If *ddrescue* was unable to recover all the data from the medium, additional *ddrescue* passes may be run to further improve the result. As an example, the screenshot below was taken after a *diskimgr* session with a damaged 3.5" floppy disk:

<figure class="image">
  <img src="{{ BASE_PATH }}/images/2019/04/ddrescue-pass2.png" alt="Screenshot of diskimgr after two ddrescue passes">
  <figcaption>Diskimgr after two ddrescue passes</figcaption>
</figure>

After an initial attempt to image this floppy with *dd* failed with errors, a first pass with *ddrescue* resulted in a 106 kB block of unreadable data. A second *ddrescue* pass with the *Direct disc mode* option switched on reduced the size of the unreadable block to a mere 512 bytes (one sector).   

## Main uses



## Final remarks

Just like *tapeimgr* and *omimgr*, *diskimgr* only works on Linux-based systems. Again this is an initial release which has had limited testing, so use at your own risk. If you run into any issues, feel free to [report them here](https://github.com/KBNLresearch/diskimgr/issues).

## Link to diskimgr

*Diskimgr* and its documentation can be found here:

[*diskimgr - Simple workflow tool for imaging block devices*](https://github.com/KBNLresearch/diskimgr)
